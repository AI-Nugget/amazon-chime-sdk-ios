//
//  AmazonChimeSDKMocks.generated.swift
//  AmazonChimeSDK
//
//  Generated by Mockingbird v0.9.0.
//  DO NOT EDIT
//

@testable import AmazonChimeSDK
@testable import Mockingbird
import AVFoundation
import CoreGraphics.CGImage
import Foundation
import Swift
import UIKit
import VideoToolbox
import os

private var genericTypesStaticMocks = Mockingbird.Synchronized<[String: Mockingbird.StaticMock]>([:])

// MARK: - Mocked ActiveSpeakerDetectorFacade

public final class ActiveSpeakerDetectorFacadeMock: AmazonChimeSDK.ActiveSpeakerDetectorFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ActiveSpeakerDetectorFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public func `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`policy`), Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`policy`, `observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addActiveSpeakerObserver`(policy: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerPolicy, observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`policy`), Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool)

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasBandwidthPriority`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`hasBandwidthPriority`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasBandwidthPriority`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public func `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeActiveSpeakerObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.ActiveSpeakerDetectorFacade` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.ActiveSpeakerDetectorFacade.Protocol) -> ActiveSpeakerDetectorFacadeMock {
  return ActiveSpeakerDetectorFacadeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ActiveSpeakerObserver

public final class ActiveSpeakerObserverMock: AmazonChimeSDK.ActiveSpeakerObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ActiveSpeakerObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked observerId

  public var `observerId`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "observerId.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getObserverId() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "observerId.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked scoresCallbackIntervalMs

  public var `scoresCallbackIntervalMs`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "scoresCallbackIntervalMs.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
  }

  public func getScoresCallbackIntervalMs() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "scoresCallbackIntervalMs.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onActiveSpeakerDetect`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo])

  public func `onActiveSpeakerDetect`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onActiveSpeakerDetect`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfo`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onActiveSpeakerDetect`(attendeeInfo: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onActiveSpeakerDetect`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onActiveSpeakerScoreChange`(scores: [AmazonChimeSDK.AttendeeInfo: Double])

  public func `onActiveSpeakerScoreChange`(scores: [AmazonChimeSDK.AttendeeInfo: Double]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onActiveSpeakerScoreChange`(scores: [AmazonChimeSDK.AttendeeInfo: Double]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`scores`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo: Double]) -> Void {
      concreteImplementation(`scores`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onActiveSpeakerScoreChange`(scores: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo: Double]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo: Double]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`scores`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onActiveSpeakerScoreChange`(scores: [AmazonChimeSDK.AttendeeInfo: Double]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo: Double]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.ActiveSpeakerObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.ActiveSpeakerObserver.Protocol) -> ActiveSpeakerObserverMock {
  return ActiveSpeakerObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ActiveSpeakerPolicy

public final class ActiveSpeakerPolicyMock: AmazonChimeSDK.ActiveSpeakerPolicy, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ActiveSpeakerPolicyMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel)

  public func `calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`), Mockingbird.ArgumentMatcher(`volume`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double {
      return concreteImplementation(`attendeeInfo`, `volume`)
    } else {
      return (implementation as! () -> Double)()
    }
  }

  public func `calculateScore`(attendeeInfo: @escaping @autoclosure () -> AmazonChimeSDK.AttendeeInfo, volume: @escaping @autoclosure () -> AmazonChimeSDK.VolumeLevel) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double, Double> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`), Mockingbird.resolve(`volume`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double, Double>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `prioritizeVideoSendBandwidthForActiveSpeaker`()

  public func `prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `prioritizeVideoSendBandwidthForActiveSpeaker`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.ActiveSpeakerPolicy` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.ActiveSpeakerPolicy.Protocol) -> ActiveSpeakerPolicyMock {
  return ActiveSpeakerPolicyMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AttendeeInfo

public final class AttendeeInfoMock: AmazonChimeSDK.AttendeeInfo, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AttendeeInfoMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendeeId: String, externalUserId: String, __file: StaticString = #file, __line: UInt = #line) -> AttendeeInfoMock {
      let mock: AttendeeInfoMock = AttendeeInfoMock(attendeeId: `attendeeId`, externalUserId: `externalUserId`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked hash

  override public var `hash`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hash.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
  }

  public func getHash() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "hash.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(attendeeId: String, externalUserId: String)

  public required override init(attendeeId: String, externalUserId: String) {
    super.init(attendeeId: `attendeeId`, externalUserId: `externalUserId`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendeeId: String, externalUserId: String) ", arguments: [Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`externalUserId`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `isEqual`(_ object: Any?)

  public override func `isEqual`(_ object: Any?) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`isEqual`(_ object: Any?) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`object`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Any?) -> Bool {
      return concreteImplementation(`object`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `isEqual`(_ object: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`object`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`isEqual`(_ object: Any?) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AttendeeInfo` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AttendeeInfo.Type) -> AttendeeInfoMock.InitializerProxy.Type {
  return AttendeeInfoMock.InitializerProxy.self
}

// MARK: - Mocked Attendee

public final class AttendeeMock: AmazonChimeSDK.Attendee, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AttendeeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendeeId: String, joinToken: String, __file: StaticString = #file, __line: UInt = #line) -> AttendeeMock {
      let mock: AttendeeMock = AttendeeMock(attendeeId: `attendeeId`, joinToken: `joinToken`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(attendeeId: String, joinToken: String)

  public required override init(attendeeId: String, joinToken: String) {
    super.init(attendeeId: `attendeeId`, joinToken: `joinToken`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendeeId: String, joinToken: String) ", arguments: [Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`joinToken`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.Attendee` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.Attendee.Type) -> AttendeeMock.InitializerProxy.Type {
  return AttendeeMock.InitializerProxy.self
}

// MARK: - Mocked AudioClientController

public final class AudioClientControllerMock: AmazonChimeSDK.AudioClientController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AudioClientControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `setMute`(mute: Bool)

  public func `setMute`(mute: Bool) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setMute`(mute: Bool) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`mute`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (Bool) -> Bool {
      return concreteImplementation(`mute`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `setMute`(mute: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`mute`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setMute`(mute: Bool) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`(audioFallbackUrl: String, audioHostUrl: String, meetingId: String, attendeeId: String, joinToken: String)

  public func `start`(audioFallbackUrl: String, audioHostUrl: String, meetingId: String, attendeeId: String, joinToken: String) throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`(audioFallbackUrl: String, audioHostUrl: String, meetingId: String, attendeeId: String, joinToken: String) throws -> Void", arguments: [Mockingbird.ArgumentMatcher(`audioFallbackUrl`), Mockingbird.ArgumentMatcher(`audioHostUrl`), Mockingbird.ArgumentMatcher(`meetingId`), Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`joinToken`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, String, String, String, String) throws -> Void {
      try concreteImplementation(`audioFallbackUrl`, `audioHostUrl`, `meetingId`, `attendeeId`, `joinToken`)
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `start`(audioFallbackUrl: @escaping @autoclosure () -> String, audioHostUrl: @escaping @autoclosure () -> String, meetingId: @escaping @autoclosure () -> String, attendeeId: @escaping @autoclosure () -> String, joinToken: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, String, String, String, String) throws -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`audioFallbackUrl`), Mockingbird.resolve(`audioHostUrl`), Mockingbird.resolve(`meetingId`), Mockingbird.resolve(`attendeeId`), Mockingbird.resolve(`joinToken`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`(audioFallbackUrl: String, audioHostUrl: String, meetingId: String, attendeeId: String, joinToken: String) throws -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, String, String, String, String) throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AudioClientController` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AudioClientController.Protocol) -> AudioClientControllerMock {
  return AudioClientControllerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AudioClientObserver

public final class AudioClientObserverMock: AmazonChimeSDK.AudioClientObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AudioClientObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `notifyAudioClientObserver`(observerFunction: (AmazonChimeSDK.AudioVideoObserver) -> Void)

  public func `notifyAudioClientObserver`(observerFunction: (AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`notifyAudioClientObserver`(observerFunction: (AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<(AmazonChimeSDK.AudioVideoObserver) -> Void>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ((AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void {
      concreteImplementation(`observerFunction`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `notifyAudioClientObserver`(observerFunction: @escaping @autoclosure () -> (AmazonChimeSDK.AudioVideoObserver) -> Void) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observerFunction`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`notifyAudioClientObserver`(observerFunction: (AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ((AmazonChimeSDK.AudioVideoObserver) -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subscribeToAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `subscribeToAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `subscribeToAudioClientStateChange`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subscribeToRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `subscribeToRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `subscribeToRealTimeEvents`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unsubscribeFromAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `unsubscribeFromAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unsubscribeFromAudioClientStateChange`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromAudioClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unsubscribeFromRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `unsubscribeFromRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unsubscribeFromRealTimeEvents`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromRealTimeEvents`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AudioClientObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AudioClientObserver.Protocol) -> AudioClientObserverMock {
  return AudioClientObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AudioVideoControllerFacade

public final class AudioVideoControllerFacadeMock: AmazonChimeSDK.AudioVideoControllerFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AudioVideoControllerFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked configuration

  public var `configuration`: AmazonChimeSDK.MeetingSessionConfiguration {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.MeetingSessionConfiguration)()
    }
  }

  public func getConfiguration() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked logger

  public var `logger`: AmazonChimeSDK.Logger {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.Logger)()
    }
  }

  public func getLogger() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public func `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public func `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`()

  public func `start`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startLocalVideo`()

  public func `startLocalVideo`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `startLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startRemoteVideo`()

  public func `startRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopLocalVideo`()

  public func `stopLocalVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopRemoteVideo`()

  public func `stopRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AudioVideoControllerFacade` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AudioVideoControllerFacade.Protocol) -> AudioVideoControllerFacadeMock {
  return AudioVideoControllerFacadeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AudioVideoFacade

public final class AudioVideoFacadeMock: AmazonChimeSDK.AudioVideoFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AudioVideoFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked configuration

  public var `configuration`: AmazonChimeSDK.MeetingSessionConfiguration {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.MeetingSessionConfiguration)()
    }
  }

  public func getConfiguration() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked logger

  public var `logger`: AmazonChimeSDK.Logger {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.Logger)()
    }
  }

  public func getLogger() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public func `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`policy`), Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`policy`, `observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addActiveSpeakerObserver`(policy: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerPolicy, observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`policy`), Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public func `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public func `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int)

  public func `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoView`), Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView, Int) -> Void {
      concreteImplementation(`videoView`, `tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bindVideoView`(videoView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView, tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoView`), Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice)

  public func `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: [Mockingbird.ArgumentMatcher(`mediaDevice`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MediaDevice) -> Void {
      concreteImplementation(`mediaDevice`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `chooseAudioDevice`(mediaDevice: @escaping @autoclosure () -> AmazonChimeSDK.MediaDevice) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`mediaDevice`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getActiveCamera`()

  public func `getActiveCamera`() -> AmazonChimeSDK.MediaDevice? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.MediaDevice? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.MediaDevice?)()
    }
  }

  public func `getActiveCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool)

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasBandwidthPriority`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`hasBandwidthPriority`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasBandwidthPriority`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `listAudioDevices`()

  public func `listAudioDevices`() -> [AmazonChimeSDK.MediaDevice] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [AmazonChimeSDK.MediaDevice] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [AmazonChimeSDK.MediaDevice])()
    }
  }

  public func `listAudioDevices`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseRemoteVideoTile`(tileId: Int)

  public func `pauseRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalMute`()

  public func `realtimeLocalMute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalMute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalUnmute`()

  public func `realtimeLocalUnmute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalUnmute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public func `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeActiveSpeakerObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public func `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public func `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resumeRemoteVideoTile`(tileId: Int)

  public func `resumeRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `resumeRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`()

  public func `start`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startLocalVideo`()

  public func `startLocalVideo`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `startLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startRemoteVideo`()

  public func `startRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopLocalVideo`()

  public func `stopLocalVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopRemoteVideo`()

  public func `stopRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `switchCamera`()

  public func `switchCamera`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `switchCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbindVideoView`(tileId: Int)

  public func `unbindVideoView`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbindVideoView`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AudioVideoFacade` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AudioVideoFacade.Protocol) -> AudioVideoFacadeMock {
  return AudioVideoFacadeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked AudioVideoObserver

public final class AudioVideoObserverMock: AmazonChimeSDK.AudioVideoObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      AudioVideoObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onAudioClientConnecting`(reconnecting: Bool)

  public func `onAudioClientConnecting`(reconnecting: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientConnecting`(reconnecting: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`reconnecting`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`reconnecting`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAudioClientConnecting`(reconnecting: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`reconnecting`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientConnecting`(reconnecting: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAudioClientReconnectionCancel`()

  public func `onAudioClientReconnectionCancel`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientReconnectionCancel`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAudioClientReconnectionCancel`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientReconnectionCancel`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAudioClientStart`(reconnecting: Bool)

  public func `onAudioClientStart`(reconnecting: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientStart`(reconnecting: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`reconnecting`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`reconnecting`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAudioClientStart`(reconnecting: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`reconnecting`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientStart`(reconnecting: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAudioClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus)

  public func `onAudioClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sessionStatus`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MeetingSessionStatus) -> Void {
      concreteImplementation(`sessionStatus`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAudioClientStop`(sessionStatus: @escaping @autoclosure () -> AmazonChimeSDK.MeetingSessionStatus) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sessionStatus`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onConnectionBecomePoor`()

  public func `onConnectionBecomePoor`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onConnectionBecomePoor`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onConnectionBecomePoor`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onConnectionBecomePoor`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onConnectionRecover`()

  public func `onConnectionRecover`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onConnectionRecover`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onConnectionRecover`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onConnectionRecover`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVideoClientConnecting`()

  public func `onVideoClientConnecting`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientConnecting`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVideoClientConnecting`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientConnecting`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVideoClientError`(status: AmazonChimeSDK.MeetingSessionStatus)

  public func `onVideoClientError`(status: AmazonChimeSDK.MeetingSessionStatus) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientError`(status: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: [Mockingbird.ArgumentMatcher(`status`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MeetingSessionStatus) -> Void {
      concreteImplementation(`status`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVideoClientError`(status: @escaping @autoclosure () -> AmazonChimeSDK.MeetingSessionStatus) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`status`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientError`(status: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVideoClientStart`()

  public func `onVideoClientStart`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientStart`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVideoClientStart`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientStart`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVideoClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus)

  public func `onVideoClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: [Mockingbird.ArgumentMatcher(`sessionStatus`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MeetingSessionStatus) -> Void {
      concreteImplementation(`sessionStatus`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVideoClientStop`(sessionStatus: @escaping @autoclosure () -> AmazonChimeSDK.MeetingSessionStatus) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`sessionStatus`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVideoClientStop`(sessionStatus: AmazonChimeSDK.MeetingSessionStatus) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MeetingSessionStatus) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.AudioVideoObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.AudioVideoObserver.Protocol) -> AudioVideoObserverMock {
  return AudioVideoObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ClientMetricsCollector

public final class ClientMetricsCollectorMock: AmazonChimeSDK.ClientMetricsCollector, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ClientMetricsCollectorMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `processAudioClientMetrics`(metrics: [AnyHashable: Any])

  public func `processAudioClientMetrics`(metrics: [AnyHashable: Any]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processAudioClientMetrics`(metrics: [AnyHashable: Any]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`metrics`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AnyHashable: Any]) -> Void {
      concreteImplementation(`metrics`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `processAudioClientMetrics`(metrics: @escaping @autoclosure () -> [AnyHashable: Any]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metrics`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processAudioClientMetrics`(metrics: [AnyHashable: Any]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `processVideoClientMetrics`(metrics: [AnyHashable: Any])

  public func `processVideoClientMetrics`(metrics: [AnyHashable: Any]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processVideoClientMetrics`(metrics: [AnyHashable: Any]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`metrics`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AnyHashable: Any]) -> Void {
      concreteImplementation(`metrics`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `processVideoClientMetrics`(metrics: @escaping @autoclosure () -> [AnyHashable: Any]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metrics`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`processVideoClientMetrics`(metrics: [AnyHashable: Any]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subscribeToMetrics`(observer: AmazonChimeSDK.MetricsObserver)

  public func `subscribeToMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `subscribeToMetrics`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unsubscribeFromMetrics`(observer: AmazonChimeSDK.MetricsObserver)

  public func `unsubscribeFromMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unsubscribeFromMetrics`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeFromMetrics`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.ClientMetricsCollector` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.ClientMetricsCollector.Protocol) -> ClientMetricsCollectorMock {
  return ClientMetricsCollectorMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked ConsoleLogger

public final class ConsoleLoggerMock: AmazonChimeSDK.ConsoleLogger, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConsoleLoggerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(name: String, level: AmazonChimeSDK.LogLevel, __file: StaticString = #file, __line: UInt = #line) -> ConsoleLoggerMock {
      let mock: ConsoleLoggerMock = ConsoleLoggerMock(name: `name`, level: `level`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked level

  override public var `level`: AmazonChimeSDK.LogLevel {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "level.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.LogLevel)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "level.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.LogLevel) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLevel() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "level.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel>(mock: self, invocation: invocation)
  }

  public func setLevel(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.LogLevel) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "level.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `debug`(debugFunction: () -> String)

  public override func `debug`(debugFunction: () -> String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debug`(debugFunction: () -> String) -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> String>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (() -> String) -> Void {
      concreteImplementation(`debugFunction`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `debug`(debugFunction: @escaping @autoclosure () -> () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`debugFunction`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debug`(debugFunction: () -> String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `default`(msg: String)

  public override func `default`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`default`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `default`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`default`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `error`(msg: String)

  public override func `error`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`error`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `error`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`error`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fault`(msg: String)

  public override func `fault`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fault`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `fault`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fault`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getLogLevel`()

  public override func `getLogLevel`() -> AmazonChimeSDK.LogLevel {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getLogLevel`() -> AmazonChimeSDK.LogLevel", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.LogLevel {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.LogLevel)()
    }
  }

  public func `getLogLevel`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getLogLevel`() -> AmazonChimeSDK.LogLevel", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `info`(msg: String)

  public override func `info`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`info`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `info`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`info`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(name: String, level: AmazonChimeSDK.LogLevel)

  public required override init(name: String, level: AmazonChimeSDK.LogLevel) {
    super.init(name: `name`, level: `level`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(name: String, level: AmazonChimeSDK.LogLevel) ", arguments: [Mockingbird.ArgumentMatcher(`name`), Mockingbird.ArgumentMatcher(`level`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `setLogLevel`(level: AmazonChimeSDK.LogLevel)

  public override func `setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void", arguments: [Mockingbird.ArgumentMatcher(`level`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.LogLevel) -> Void {
      concreteImplementation(`level`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setLogLevel`(level: @escaping @autoclosure () -> AmazonChimeSDK.LogLevel) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`level`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.ConsoleLogger` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.ConsoleLogger.Type) -> ConsoleLoggerMock.InitializerProxy.Type {
  return ConsoleLoggerMock.InitializerProxy.self
}

// MARK: - Mocked Constants

public final class ConstantsMock: AmazonChimeSDK.Constants, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      ConstantsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {}
}

/// Create a source-attributed `AmazonChimeSDK.Constants` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.Constants.Type) -> ConstantsMock.InitializerProxy.Type {
  return ConstantsMock.InitializerProxy.self
}

// MARK: - Mocked CreateAttendeeResponse

public final class CreateAttendeeResponseMock: AmazonChimeSDK.CreateAttendeeResponse, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CreateAttendeeResponseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendee: AmazonChimeSDK.Attendee, __file: StaticString = #file, __line: UInt = #line) -> CreateAttendeeResponseMock {
      let mock: CreateAttendeeResponseMock = CreateAttendeeResponseMock(attendee: `attendee`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(attendee: AmazonChimeSDK.Attendee)

  public required override init(attendee: AmazonChimeSDK.Attendee) {
    super.init(attendee: `attendee`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendee: AmazonChimeSDK.Attendee) ", arguments: [Mockingbird.ArgumentMatcher(`attendee`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.CreateAttendeeResponse` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.CreateAttendeeResponse.Type) -> CreateAttendeeResponseMock.InitializerProxy.Type {
  return CreateAttendeeResponseMock.InitializerProxy.self
}

// MARK: - Mocked CreateMeetingResponse

public final class CreateMeetingResponseMock: AmazonChimeSDK.CreateMeetingResponse, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      CreateMeetingResponseMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(meeting: AmazonChimeSDK.Meeting, __file: StaticString = #file, __line: UInt = #line) -> CreateMeetingResponseMock {
      let mock: CreateMeetingResponseMock = CreateMeetingResponseMock(meeting: `meeting`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(meeting: AmazonChimeSDK.Meeting)

  public required override init(meeting: AmazonChimeSDK.Meeting) {
    super.init(meeting: `meeting`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(meeting: AmazonChimeSDK.Meeting) ", arguments: [Mockingbird.ArgumentMatcher(`meeting`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.CreateMeetingResponse` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.CreateMeetingResponse.Type) -> CreateMeetingResponseMock.InitializerProxy.Type {
  return CreateMeetingResponseMock.InitializerProxy.self
}

// MARK: - Mocked DefaultActiveSpeakerDetector

public final class DefaultActiveSpeakerDetectorMock: AmazonChimeSDK.DefaultActiveSpeakerDetector, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultActiveSpeakerDetectorMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioClientObserver: AmazonChimeSDK.AudioClientObserver, selfAttendeeId: String, __file: StaticString = #file, __line: UInt = #line) -> DefaultActiveSpeakerDetectorMock {
      let mock: DefaultActiveSpeakerDetectorMock = DefaultActiveSpeakerDetectorMock(audioClientObserver: `audioClientObserver`, selfAttendeeId: `selfAttendeeId`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public override func `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`policy`), Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`policy`, `observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addActiveSpeakerObserver`(policy: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerPolicy, observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`policy`), Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool)

  public override func `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasBandwidthPriority`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`hasBandwidthPriority`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasBandwidthPriority`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioClientObserver: AmazonChimeSDK.AudioClientObserver, selfAttendeeId: String)

  public required override init(audioClientObserver: AmazonChimeSDK.AudioClientObserver, selfAttendeeId: String) {
    super.init(audioClientObserver: `audioClientObserver`, selfAttendeeId: `selfAttendeeId`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioClientObserver: AmazonChimeSDK.AudioClientObserver, selfAttendeeId: String) ", arguments: [Mockingbird.ArgumentMatcher(`audioClientObserver`), Mockingbird.ArgumentMatcher(`selfAttendeeId`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `onAttendeesJoin`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo])

  public override func `onAttendeesJoin`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesJoin`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfos`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfos`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesJoin`(attendeeInfo attendeeInfos: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfos`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesJoin`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesLeave`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo])

  public override func `onAttendeesLeave`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesLeave`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfos`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfos`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesLeave`(attendeeInfo attendeeInfos: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfos`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesLeave`(attendeeInfo attendeeInfos: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesMute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo])

  public override func `onAttendeesMute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesMute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeIds`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeIds`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesMute`(attendeeInfo attendeeIds: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeIds`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesMute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesUnmute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo])

  public override func `onAttendeesUnmute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesUnmute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeIds`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeIds`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesUnmute`(attendeeInfo attendeeIds: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeIds`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesUnmute`(attendeeInfo attendeeIds: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate])

  public override func `onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`signalUpdates`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.SignalUpdate]) -> Void {
      concreteImplementation(`signalUpdates`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onSignalStrengthChange`(signalUpdates: @escaping @autoclosure () -> [AmazonChimeSDK.SignalUpdate]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.SignalUpdate]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`signalUpdates`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.SignalUpdate]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVolumeChange`(volumeUpdates attendeeVolumeMap: [AmazonChimeSDK.VolumeUpdate])

  public override func `onVolumeChange`(volumeUpdates attendeeVolumeMap: [AmazonChimeSDK.VolumeUpdate]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVolumeChange`(volumeUpdates attendeeVolumeMap: [AmazonChimeSDK.VolumeUpdate]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeVolumeMap`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.VolumeUpdate]) -> Void {
      concreteImplementation(`attendeeVolumeMap`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVolumeChange`(volumeUpdates attendeeVolumeMap: @escaping @autoclosure () -> [AmazonChimeSDK.VolumeUpdate]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.VolumeUpdate]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeVolumeMap`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVolumeChange`(volumeUpdates attendeeVolumeMap: [AmazonChimeSDK.VolumeUpdate]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.VolumeUpdate]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public override func `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeActiveSpeakerObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultActiveSpeakerDetector` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultActiveSpeakerDetector.Type) -> DefaultActiveSpeakerDetectorMock.InitializerProxy.Type {
  return DefaultActiveSpeakerDetectorMock.InitializerProxy.self
}

// MARK: - Mocked DefaultActiveSpeakerPolicy

public final class DefaultActiveSpeakerPolicyMock: AmazonChimeSDK.DefaultActiveSpeakerPolicy, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultActiveSpeakerPolicyMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(speakerWeight: Double, cutoffThreshold: Double, takeoverRate: Double, __file: StaticString = #file, __line: UInt = #line) -> DefaultActiveSpeakerPolicyMock {
      let mock: DefaultActiveSpeakerPolicyMock = DefaultActiveSpeakerPolicyMock(speakerWeight: `speakerWeight`, cutoffThreshold: `cutoffThreshold`, takeoverRate: `takeoverRate`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel)

  public override func `calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`), Mockingbird.ArgumentMatcher(`volume`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double {
      return concreteImplementation(`attendeeInfo`, `volume`)
    } else {
      return (implementation as! () -> Double)()
    }
  }

  public func `calculateScore`(attendeeInfo: @escaping @autoclosure () -> AmazonChimeSDK.AttendeeInfo, volume: @escaping @autoclosure () -> AmazonChimeSDK.VolumeLevel) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double, Double> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`), Mockingbird.resolve(`volume`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`calculateScore`(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volume: AmazonChimeSDK.VolumeLevel) -> Double", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AttendeeInfo, AmazonChimeSDK.VolumeLevel) -> Double, Double>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(speakerWeight: Double, cutoffThreshold: Double, takeoverRate: Double)

  public required override init(speakerWeight: Double, cutoffThreshold: Double, takeoverRate: Double) {
    super.init(speakerWeight: `speakerWeight`, cutoffThreshold: `cutoffThreshold`, takeoverRate: `takeoverRate`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(speakerWeight: Double, cutoffThreshold: Double, takeoverRate: Double) ", arguments: [Mockingbird.ArgumentMatcher(`speakerWeight`), Mockingbird.ArgumentMatcher(`cutoffThreshold`), Mockingbird.ArgumentMatcher(`takeoverRate`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `prioritizeVideoSendBandwidthForActiveSpeaker`()

  public override func `prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `prioritizeVideoSendBandwidthForActiveSpeaker`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`prioritizeVideoSendBandwidthForActiveSpeaker`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultActiveSpeakerPolicy` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultActiveSpeakerPolicy.Type) -> DefaultActiveSpeakerPolicyMock.InitializerProxy.Type {
  return DefaultActiveSpeakerPolicyMock.InitializerProxy.self
}

// MARK: - Mocked DefaultAudioClientController

public final class DefaultAudioClientControllerMock: AmazonChimeSDK.DefaultAudioClientController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultAudioClientControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioClient: AudioClient, audioClientObserver: AmazonChimeSDK.AudioClientObserver, audioSession: AVAudioSession, __file: StaticString = #file, __line: UInt = #line) -> DefaultAudioClientControllerMock {
      let mock: DefaultAudioClientControllerMock = DefaultAudioClientControllerMock(audioClient: `audioClient`, audioClientObserver: `audioClientObserver`, audioSession: `audioSession`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(audioClient: AudioClient, audioClientObserver: AmazonChimeSDK.AudioClientObserver, audioSession: AVAudioSession)

  public required override init(audioClient: AudioClient, audioClientObserver: AmazonChimeSDK.AudioClientObserver, audioSession: AVAudioSession) {
    super.init(audioClient: `audioClient`, audioClientObserver: `audioClientObserver`, audioSession: `audioSession`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioClient: AudioClient, audioClientObserver: AmazonChimeSDK.AudioClientObserver, audioSession: AVAudioSession) ", arguments: [Mockingbird.ArgumentMatcher(`audioClient`), Mockingbird.ArgumentMatcher(`audioClientObserver`), Mockingbird.ArgumentMatcher(`audioSession`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultAudioClientController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultAudioClientController.Type) -> DefaultAudioClientControllerMock.InitializerProxy.Type {
  return DefaultAudioClientControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultAudioClientObserver

public final class DefaultAudioClientObserverMock: AmazonChimeSDK.DefaultAudioClientObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultAudioClientObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioClient: AudioClient, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, __file: StaticString = #file, __line: UInt = #line) -> DefaultAudioClientObserverMock {
      let mock: DefaultAudioClientObserverMock = DefaultAudioClientObserverMock(audioClient: `audioClient`, clientMetricsCollector: `clientMetricsCollector`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `audioClientStateChanged`(_ audioClientState: audio_client_state_t, status: audio_client_status_t)

  public override func `audioClientStateChanged`(_ audioClientState: audio_client_state_t, status: audio_client_status_t) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioClientStateChanged`(_ audioClientState: audio_client_state_t, status: audio_client_status_t) -> Void", arguments: [Mockingbird.ArgumentMatcher(`audioClientState`), Mockingbird.ArgumentMatcher(`status`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (audio_client_state_t, audio_client_status_t) -> Void {
      concreteImplementation(`audioClientState`, `status`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `audioClientStateChanged`(_ audioClientState: @escaping @autoclosure () -> audio_client_state_t, status: @escaping @autoclosure () -> audio_client_status_t) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (audio_client_state_t, audio_client_status_t) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`audioClientState`), Mockingbird.resolve(`status`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioClientStateChanged`(_ audioClientState: audio_client_state_t, status: audio_client_status_t) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (audio_client_state_t, audio_client_status_t) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `audioMetricsChanged`(_ metrics: [AnyHashable: Any]?)

  public override func `audioMetricsChanged`(_ metrics: [AnyHashable: Any]?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioMetricsChanged`(_ metrics: [AnyHashable: Any]?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`metrics`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AnyHashable: Any]?) -> Void {
      concreteImplementation(`metrics`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `audioMetricsChanged`(_ metrics: @escaping @autoclosure () -> [AnyHashable: Any]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metrics`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioMetricsChanged`(_ metrics: [AnyHashable: Any]?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioClient: AudioClient, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector)

  public required override init(audioClient: AudioClient, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector) {
    super.init(audioClient: `audioClient`, clientMetricsCollector: `clientMetricsCollector`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioClient: AudioClient, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector) ", arguments: [Mockingbird.ArgumentMatcher(`audioClient`), Mockingbird.ArgumentMatcher(`clientMetricsCollector`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `signalStrengthChanged`(_ signalStrengths: [Any]?)

  public override func `signalStrengthChanged`(_ signalStrengths: [Any]?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`signalStrengthChanged`(_ signalStrengths: [Any]?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`signalStrengths`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Any]?) -> Void {
      concreteImplementation(`signalStrengths`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `signalStrengthChanged`(_ signalStrengths: @escaping @autoclosure () -> [Any]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Any]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`signalStrengths`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`signalStrengthChanged`(_ signalStrengths: [Any]?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Any]?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `volumeStateChanged`(_ volumes: [Any]?)

  public override func `volumeStateChanged`(_ volumes: [Any]?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`volumeStateChanged`(_ volumes: [Any]?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`volumes`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([Any]?) -> Void {
      concreteImplementation(`volumes`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `volumeStateChanged`(_ volumes: @escaping @autoclosure () -> [Any]?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Any]?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`volumes`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`volumeStateChanged`(_ volumes: [Any]?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([Any]?) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultAudioClientObserver` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultAudioClientObserver.Type) -> DefaultAudioClientObserverMock.InitializerProxy.Type {
  return DefaultAudioClientObserverMock.InitializerProxy.self
}

// MARK: - Mocked DefaultAudioClient

public final class DefaultAudioClientMock: AmazonChimeSDK.DefaultAudioClient, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultAudioClientMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(logger: AmazonChimeSDK.Logger, __file: StaticString = #file, __line: UInt = #line) -> DefaultAudioClientMock {
      let mock: DefaultAudioClientMock = DefaultAudioClientMock(logger: `logger`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `audioLogCallBack`(_ logLevel: loglevel_t, msg: String!)

  public override func `audioLogCallBack`(_ logLevel: loglevel_t, msg: String!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioLogCallBack`(_ logLevel: loglevel_t, msg: String!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`logLevel`), Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (loglevel_t, String) -> Void {
      concreteImplementation(`logLevel`, `msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `audioLogCallBack`(_ logLevel: @escaping @autoclosure () -> loglevel_t, msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (loglevel_t, String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`logLevel`), Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`audioLogCallBack`(_ logLevel: loglevel_t, msg: String!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (loglevel_t, String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(logger: AmazonChimeSDK.Logger)

  public required override init(logger: AmazonChimeSDK.Logger) {
    super.init(logger: `logger`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(logger: AmazonChimeSDK.Logger) ", arguments: [Mockingbird.ArgumentMatcher(`logger`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultAudioClient` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultAudioClient.Type) -> DefaultAudioClientMock.InitializerProxy.Type {
  return DefaultAudioClientMock.InitializerProxy.self
}

// MARK: - Mocked DefaultAudioVideoController

public final class DefaultAudioVideoControllerMock: AmazonChimeSDK.DefaultAudioVideoController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultAudioVideoControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, videoClientController: AmazonChimeSDK.VideoClientController, configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger, __file: StaticString = #file, __line: UInt = #line) -> DefaultAudioVideoControllerMock {
      let mock: DefaultAudioVideoControllerMock = DefaultAudioVideoControllerMock(audioClientController: `audioClientController`, audioClientObserver: `audioClientObserver`, clientMetricsCollector: `clientMetricsCollector`, videoClientController: `videoClientController`, configuration: `configuration`, logger: `logger`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public override func `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public override func `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, videoClientController: AmazonChimeSDK.VideoClientController, configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger)

  public required override init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, videoClientController: AmazonChimeSDK.VideoClientController, configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger) {
    super.init(audioClientController: `audioClientController`, audioClientObserver: `audioClientObserver`, clientMetricsCollector: `clientMetricsCollector`, videoClientController: `videoClientController`, configuration: `configuration`, logger: `logger`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, videoClientController: AmazonChimeSDK.VideoClientController, configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger) ", arguments: [Mockingbird.ArgumentMatcher(`audioClientController`), Mockingbird.ArgumentMatcher(`audioClientObserver`), Mockingbird.ArgumentMatcher(`clientMetricsCollector`), Mockingbird.ArgumentMatcher(`videoClientController`), Mockingbird.ArgumentMatcher(`configuration`), Mockingbird.ArgumentMatcher(`logger`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public override func `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public override func `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`()

  public override func `start`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startLocalVideo`()

  public override func `startLocalVideo`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `startLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startRemoteVideo`()

  public override func `startRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public override func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopLocalVideo`()

  public override func `stopLocalVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopRemoteVideo`()

  public override func `stopRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultAudioVideoController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultAudioVideoController.Type) -> DefaultAudioVideoControllerMock.InitializerProxy.Type {
  return DefaultAudioVideoControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultAudioVideoFacade

public final class DefaultAudioVideoFacadeMock: AmazonChimeSDK.DefaultAudioVideoFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultAudioVideoFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioVideoController: AmazonChimeSDK.AudioVideoControllerFacade, realtimeController: AmazonChimeSDK.RealtimeControllerFacade, deviceController: AmazonChimeSDK.DeviceController, videoTileController: AmazonChimeSDK.VideoTileController, activeSpeakerDetector: AmazonChimeSDK.ActiveSpeakerDetectorFacade, __file: StaticString = #file, __line: UInt = #line) -> DefaultAudioVideoFacadeMock {
      let mock: DefaultAudioVideoFacadeMock = DefaultAudioVideoFacadeMock(audioVideoController: `audioVideoController`, realtimeController: `realtimeController`, deviceController: `deviceController`, videoTileController: `videoTileController`, activeSpeakerDetector: `activeSpeakerDetector`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public override func `addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`policy`), Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`policy`, `observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addActiveSpeakerObserver`(policy: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerPolicy, observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`policy`), Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addActiveSpeakerObserver`(policy: AmazonChimeSDK.ActiveSpeakerPolicy, observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerPolicy, AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public override func `addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public override func `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public override func `addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public override func `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public override func `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int)

  public override func `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoView`), Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView, Int) -> Void {
      concreteImplementation(`videoView`, `tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bindVideoView`(videoView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView, tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoView`), Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice)

  public override func `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: [Mockingbird.ArgumentMatcher(`mediaDevice`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MediaDevice) -> Void {
      concreteImplementation(`mediaDevice`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `chooseAudioDevice`(mediaDevice: @escaping @autoclosure () -> AmazonChimeSDK.MediaDevice) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`mediaDevice`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getActiveCamera`()

  public override func `getActiveCamera`() -> AmazonChimeSDK.MediaDevice? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.MediaDevice? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.MediaDevice?)()
    }
  }

  public func `getActiveCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool)

  public override func `hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`hasBandwidthPriority`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Bool) -> Void {
      concreteImplementation(`hasBandwidthPriority`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `hasBandwidthPriorityCallback`(hasBandwidthPriority: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`hasBandwidthPriority`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`hasBandwidthPriorityCallback`(hasBandwidthPriority: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioVideoController: AmazonChimeSDK.AudioVideoControllerFacade, realtimeController: AmazonChimeSDK.RealtimeControllerFacade, deviceController: AmazonChimeSDK.DeviceController, videoTileController: AmazonChimeSDK.VideoTileController, activeSpeakerDetector: AmazonChimeSDK.ActiveSpeakerDetectorFacade)

  public required override init(audioVideoController: AmazonChimeSDK.AudioVideoControllerFacade, realtimeController: AmazonChimeSDK.RealtimeControllerFacade, deviceController: AmazonChimeSDK.DeviceController, videoTileController: AmazonChimeSDK.VideoTileController, activeSpeakerDetector: AmazonChimeSDK.ActiveSpeakerDetectorFacade) {
    super.init(audioVideoController: `audioVideoController`, realtimeController: `realtimeController`, deviceController: `deviceController`, videoTileController: `videoTileController`, activeSpeakerDetector: `activeSpeakerDetector`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioVideoController: AmazonChimeSDK.AudioVideoControllerFacade, realtimeController: AmazonChimeSDK.RealtimeControllerFacade, deviceController: AmazonChimeSDK.DeviceController, videoTileController: AmazonChimeSDK.VideoTileController, activeSpeakerDetector: AmazonChimeSDK.ActiveSpeakerDetectorFacade) ", arguments: [Mockingbird.ArgumentMatcher(`audioVideoController`), Mockingbird.ArgumentMatcher(`realtimeController`), Mockingbird.ArgumentMatcher(`deviceController`), Mockingbird.ArgumentMatcher(`videoTileController`), Mockingbird.ArgumentMatcher(`activeSpeakerDetector`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `listAudioDevices`()

  public override func `listAudioDevices`() -> [AmazonChimeSDK.MediaDevice] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [AmazonChimeSDK.MediaDevice] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [AmazonChimeSDK.MediaDevice])()
    }
  }

  public func `listAudioDevices`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseRemoteVideoTile`(tileId: Int)

  public override func `pauseRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalMute`()

  public override func `realtimeLocalMute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalMute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalUnmute`()

  public override func `realtimeLocalUnmute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalUnmute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver)

  public override func `removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.ActiveSpeakerObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeActiveSpeakerObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.ActiveSpeakerObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeActiveSpeakerObserver`(observer: AmazonChimeSDK.ActiveSpeakerObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.ActiveSpeakerObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver)

  public override func `removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeAudioVideoObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeAudioVideoObserver`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public override func `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver)

  public override func `removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MetricsObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeMetricsObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.MetricsObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeMetricsObserver`(observer: AmazonChimeSDK.MetricsObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MetricsObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public override func `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public override func `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resumeRemoteVideoTile`(tileId: Int)

  public override func `resumeRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `resumeRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`()

  public override func `start`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startLocalVideo`()

  public override func `startLocalVideo`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `startLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startRemoteVideo`()

  public override func `startRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public override func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopLocalVideo`()

  public override func `stopLocalVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopRemoteVideo`()

  public override func `stopRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `switchCamera`()

  public override func `switchCamera`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `switchCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbindVideoView`(tileId: Int)

  public override func `unbindVideoView`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbindVideoView`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultAudioVideoFacade` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultAudioVideoFacade.Type) -> DefaultAudioVideoFacadeMock.InitializerProxy.Type {
  return DefaultAudioVideoFacadeMock.InitializerProxy.self
}

// MARK: - Mocked DefaultClientMetricsCollector

public final class DefaultClientMetricsCollectorMock: AmazonChimeSDK.DefaultClientMetricsCollector, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultClientMetricsCollectorMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    super.init()
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultClientMetricsCollector` concrete class mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultClientMetricsCollector.Type) -> DefaultClientMetricsCollectorMock {
  return DefaultClientMetricsCollectorMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DefaultDeviceController

public final class DefaultDeviceControllerMock: AmazonChimeSDK.DefaultDeviceController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultDeviceControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioSession: AVAudioSession, videoClientController: AmazonChimeSDK.VideoClientController, logger: AmazonChimeSDK.Logger, __file: StaticString = #file, __line: UInt = #line) -> DefaultDeviceControllerMock {
      let mock: DefaultDeviceControllerMock = DefaultDeviceControllerMock(audioSession: `audioSession`, videoClientController: `videoClientController`, logger: `logger`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public override func `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice)

  public override func `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: [Mockingbird.ArgumentMatcher(`mediaDevice`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MediaDevice) -> Void {
      concreteImplementation(`mediaDevice`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `chooseAudioDevice`(mediaDevice: @escaping @autoclosure () -> AmazonChimeSDK.MediaDevice) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`mediaDevice`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getActiveCamera`()

  public override func `getActiveCamera`() -> AmazonChimeSDK.MediaDevice? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.MediaDevice? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.MediaDevice?)()
    }
  }

  public func `getActiveCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioSession: AVAudioSession, videoClientController: AmazonChimeSDK.VideoClientController, logger: AmazonChimeSDK.Logger)

  public required override init(audioSession: AVAudioSession, videoClientController: AmazonChimeSDK.VideoClientController, logger: AmazonChimeSDK.Logger) {
    super.init(audioSession: `audioSession`, videoClientController: `videoClientController`, logger: `logger`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioSession: AVAudioSession, videoClientController: AmazonChimeSDK.VideoClientController, logger: AmazonChimeSDK.Logger) ", arguments: [Mockingbird.ArgumentMatcher(`audioSession`), Mockingbird.ArgumentMatcher(`videoClientController`), Mockingbird.ArgumentMatcher(`logger`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `listAudioDevices`()

  public override func `listAudioDevices`() -> [AmazonChimeSDK.MediaDevice] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [AmazonChimeSDK.MediaDevice] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [AmazonChimeSDK.MediaDevice])()
    }
  }

  public func `listAudioDevices`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public override func `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `switchCamera`()

  public override func `switchCamera`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `switchCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultDeviceController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultDeviceController.Type) -> DefaultDeviceControllerMock.InitializerProxy.Type {
  return DefaultDeviceControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultMeetingSession

public final class DefaultMeetingSessionMock: AmazonChimeSDK.DefaultMeetingSession, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultMeetingSessionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger, __file: StaticString = #file, __line: UInt = #line) -> DefaultMeetingSessionMock {
      let mock: DefaultMeetingSessionMock = DefaultMeetingSessionMock(configuration: `configuration`, logger: `logger`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger)

  public required override init(configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger) {
    super.init(configuration: `configuration`, logger: `logger`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(configuration: AmazonChimeSDK.MeetingSessionConfiguration, logger: AmazonChimeSDK.Logger) ", arguments: [Mockingbird.ArgumentMatcher(`configuration`), Mockingbird.ArgumentMatcher(`logger`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultMeetingSession` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultMeetingSession.Type) -> DefaultMeetingSessionMock.InitializerProxy.Type {
  return DefaultMeetingSessionMock.InitializerProxy.self
}

// MARK: - Mocked DefaultRealtimeController

public final class DefaultRealtimeControllerMock: AmazonChimeSDK.DefaultRealtimeController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultRealtimeControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver, __file: StaticString = #file, __line: UInt = #line) -> DefaultRealtimeControllerMock {
      let mock: DefaultRealtimeControllerMock = DefaultRealtimeControllerMock(audioClientController: `audioClientController`, audioClientObserver: `audioClientObserver`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public override func `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver)

  public required override init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver) {
    super.init(audioClientController: `audioClientController`, audioClientObserver: `audioClientObserver`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioClientController: AmazonChimeSDK.AudioClientController, audioClientObserver: AmazonChimeSDK.AudioClientObserver) ", arguments: [Mockingbird.ArgumentMatcher(`audioClientController`), Mockingbird.ArgumentMatcher(`audioClientObserver`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `realtimeLocalMute`()

  public override func `realtimeLocalMute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalMute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalUnmute`()

  public override func `realtimeLocalUnmute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalUnmute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public override func `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultRealtimeController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultRealtimeController.Type) -> DefaultRealtimeControllerMock.InitializerProxy.Type {
  return DefaultRealtimeControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultVideoClientController

public final class DefaultVideoClientControllerMock: AmazonChimeSDK.DefaultVideoClientController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultVideoClientControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(logger: AmazonChimeSDK.Logger, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector, __file: StaticString = #file, __line: UInt = #line) -> DefaultVideoClientControllerMock {
      let mock: DefaultVideoClientControllerMock = DefaultVideoClientControllerMock(logger: `logger`, clientMetricsCollector: `clientMetricsCollector`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked clientMetricsCollector

  override public var `clientMetricsCollector`: AmazonChimeSDK.ClientMetricsCollector {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "clientMetricsCollector.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.ClientMetricsCollector)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "clientMetricsCollector.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.ClientMetricsCollector) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getClientMetricsCollector() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.ClientMetricsCollector, AmazonChimeSDK.ClientMetricsCollector> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "clientMetricsCollector.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.ClientMetricsCollector, AmazonChimeSDK.ClientMetricsCollector>(mock: self, invocation: invocation)
  }

  public func setClientMetricsCollector(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.ClientMetricsCollector) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.ClientMetricsCollector) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "clientMetricsCollector.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.ClientMetricsCollector) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked joinToken

  override public var `joinToken`: String? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "joinToken.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "joinToken.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getJoinToken() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "joinToken.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?>(mock: self, invocation: invocation)
  }

  public func setJoinToken(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "joinToken.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked logger

  override public var `logger`: AmazonChimeSDK.Logger {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.Logger)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.Logger) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getLogger() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger>(mock: self, invocation: invocation)
  }

  public func setLogger(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.Logger) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.Logger) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.Logger) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked meetingId

  override public var `meetingId`: String? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "meetingId.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "meetingId.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getMeetingId() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "meetingId.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?>(mock: self, invocation: invocation)
  }

  public func setMeetingId(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "meetingId.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked signalingUrl

  override public var `signalingUrl`: String? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "signalingUrl.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "signalingUrl.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getSignalingUrl() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "signalingUrl.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?>(mock: self, invocation: invocation)
  }

  public func setSignalingUrl(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "signalingUrl.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked turnControlUrl

  override public var `turnControlUrl`: String? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "turnControlUrl.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "turnControlUrl.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (String?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTurnControlUrl() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "turnControlUrl.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String?, String?>(mock: self, invocation: invocation)
  }

  public func setTurnControlUrl(_ newValue: @escaping @autoclosure () -> String?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "turnControlUrl.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (String?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoClientState

  override public var `videoClientState`: AmazonChimeSDK.VideoClientState {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClientState.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoClientState)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClientState.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoClientState) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoClientState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoClientState, AmazonChimeSDK.VideoClientState> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClientState.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoClientState, AmazonChimeSDK.VideoClientState>(mock: self, invocation: invocation)
  }

  public func setVideoClientState(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.VideoClientState) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoClientState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClientState.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoClientState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoClient

  override public var `videoClient`: VideoClient? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClient.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> VideoClient?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClient.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (VideoClient?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoClient() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> VideoClient?, VideoClient?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClient.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> VideoClient?, VideoClient?>(mock: self, invocation: invocation)
  }

  public func setVideoClient(_ newValue: @escaping @autoclosure () -> VideoClient?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (VideoClient?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoClient.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (VideoClient?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoObservers

  override public var `videoObservers`: NSMutableSet {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoObservers.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> NSMutableSet)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoObservers.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (NSMutableSet) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoObservers() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSMutableSet, NSMutableSet> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoObservers.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSMutableSet, NSMutableSet>(mock: self, invocation: invocation)
  }

  public func setVideoObservers(_ newValue: @escaping @autoclosure () -> NSMutableSet) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSMutableSet) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoObservers.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSMutableSet) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoTileControllerObservers

  override public var `videoTileControllerObservers`: NSMutableSet {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoTileControllerObservers.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> NSMutableSet)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoTileControllerObservers.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (NSMutableSet) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoTileControllerObservers() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSMutableSet, NSMutableSet> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoTileControllerObservers.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> NSMutableSet, NSMutableSet>(mock: self, invocation: invocation)
  }

  public func setVideoTileControllerObservers(_ newValue: @escaping @autoclosure () -> NSMutableSet) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSMutableSet) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoTileControllerObservers.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (NSMutableSet) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(logger: AmazonChimeSDK.Logger, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector)

  public required override init(logger: AmazonChimeSDK.Logger, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector) {
    super.init(logger: `logger`, clientMetricsCollector: `clientMetricsCollector`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(logger: AmazonChimeSDK.Logger, clientMetricsCollector: AmazonChimeSDK.ClientMetricsCollector) ", arguments: [Mockingbird.ArgumentMatcher(`logger`), Mockingbird.ArgumentMatcher(`clientMetricsCollector`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `initialize`()

  public override func `initialize`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`initialize`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `initialize`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`initialize`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `isDeviceFrontFacing`(videoDevice: VideoDevice)

  public override func `isDeviceFrontFacing`(videoDevice: VideoDevice) -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`isDeviceFrontFacing`(videoDevice: VideoDevice) -> Bool", arguments: [Mockingbird.ArgumentMatcher(`videoDevice`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? (VideoDevice) -> Bool {
      return concreteImplementation(`videoDevice`)
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `isDeviceFrontFacing`(videoDevice: @escaping @autoclosure () -> VideoDevice) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (VideoDevice) -> Bool, Bool> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoDevice`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`isDeviceFrontFacing`(videoDevice: VideoDevice) -> Bool", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (VideoDevice) -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setFrontCameraAsCurrentDevice`()

  public override func `setFrontCameraAsCurrentDevice`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setFrontCameraAsCurrentDevice`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setFrontCameraAsCurrentDevice`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setFrontCameraAsCurrentDevice`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startInitializedVideoClient`()

  public override func `startInitializedVideoClient`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startInitializedVideoClient`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startInitializedVideoClient`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startInitializedVideoClient`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultVideoClientController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultVideoClientController.Type) -> DefaultVideoClientControllerMock.InitializerProxy.Type {
  return DefaultVideoClientControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultVideoClient

public final class DefaultVideoClientMock: AmazonChimeSDK.DefaultVideoClient, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultVideoClientMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(logger: AmazonChimeSDK.Logger, __file: StaticString = #file, __line: UInt = #line) -> DefaultVideoClientMock {
      let mock: DefaultVideoClientMock = DefaultVideoClientMock(logger: `logger`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(logger: AmazonChimeSDK.Logger)

  public required override init(logger: AmazonChimeSDK.Logger) {
    super.init(logger: `logger`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(logger: AmazonChimeSDK.Logger) ", arguments: [Mockingbird.ArgumentMatcher(`logger`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `videoLogCallBack`(_ logLevel: video_client_loglevel_t, msg: String!)

  public override func `videoLogCallBack`(_ logLevel: video_client_loglevel_t, msg: String!) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`videoLogCallBack`(_ logLevel: video_client_loglevel_t, msg: String!) -> Void", arguments: [Mockingbird.ArgumentMatcher(`logLevel`), Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (video_client_loglevel_t, String) -> Void {
      concreteImplementation(`logLevel`, `msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `videoLogCallBack`(_ logLevel: @escaping @autoclosure () -> video_client_loglevel_t, msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (video_client_loglevel_t, String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`logLevel`), Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`videoLogCallBack`(_ logLevel: video_client_loglevel_t, msg: String!) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (video_client_loglevel_t, String) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultVideoClient` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultVideoClient.Type) -> DefaultVideoClientMock.InitializerProxy.Type {
  return DefaultVideoClientMock.InitializerProxy.self
}

// MARK: - Mocked DefaultVideoRenderView

public final class DefaultVideoRenderViewMock: AmazonChimeSDK.DefaultVideoRenderView, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultVideoRenderViewMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(coder: NSCoder, __file: StaticString = #file, __line: UInt = #line) -> DefaultVideoRenderViewMock? {
      let mock: DefaultVideoRenderViewMock? = DefaultVideoRenderViewMock(coder: `coder`)
      mock?.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked mirror

  override public var `mirror`: Bool {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "mirror.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Bool)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "mirror.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Bool) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getMirror() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "mirror.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  public func setMirror(_ newValue: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "mirror.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init?(coder: NSCoder)

  public required init?(coder: NSCoder) {
    super.init(coder: `coder`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init?(coder: NSCoder) ", arguments: [Mockingbird.ArgumentMatcher(`coder`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `renderFrame`(frame: Any?)

  public override func `renderFrame`(frame: Any?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?) -> Void {
      concreteImplementation(`frame`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `renderFrame`(frame: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultVideoRenderView` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultVideoRenderView.Type) -> DefaultVideoRenderViewMock.InitializerProxy.Type {
  return DefaultVideoRenderViewMock.InitializerProxy.self
}

// MARK: - Mocked DefaultVideoTileController

public final class DefaultVideoTileControllerMock: AmazonChimeSDK.DefaultVideoTileController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultVideoTileControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(logger: AmazonChimeSDK.Logger, videoClientController: AmazonChimeSDK.VideoClientController, __file: StaticString = #file, __line: UInt = #line) -> DefaultVideoTileControllerMock {
      let mock: DefaultVideoTileControllerMock = DefaultVideoTileControllerMock(logger: `logger`, videoClientController: `videoClientController`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public override func `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int)

  public override func `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoView`), Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView, Int) -> Void {
      concreteImplementation(`videoView`, `tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bindVideoView`(videoView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView, tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoView`), Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(logger: AmazonChimeSDK.Logger, videoClientController: AmazonChimeSDK.VideoClientController)

  public required override init(logger: AmazonChimeSDK.Logger, videoClientController: AmazonChimeSDK.VideoClientController) {
    super.init(logger: `logger`, videoClientController: `videoClientController`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(logger: AmazonChimeSDK.Logger, videoClientController: AmazonChimeSDK.VideoClientController) ", arguments: [Mockingbird.ArgumentMatcher(`logger`), Mockingbird.ArgumentMatcher(`videoClientController`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int)

  public override func `onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`), Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`pauseState`), Mockingbird.ArgumentMatcher(`videoId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void {
      concreteImplementation(`frame`, `attendeeId`, `pauseState`, `videoId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onReceiveFrame`(frame: @escaping @autoclosure () -> Any?, attendeeId: @escaping @autoclosure () -> String?, pauseState: @escaping @autoclosure () -> AmazonChimeSDK.VideoPauseState, videoId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`), Mockingbird.resolve(`attendeeId`), Mockingbird.resolve(`pauseState`), Mockingbird.resolve(`videoId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseRemoteVideoTile`(tileId: Int)

  public override func `pauseRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public override func `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resumeRemoteVideoTile`(tileId: Int)

  public override func `resumeRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `resumeRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbindVideoView`(tileId: Int)

  public override func `unbindVideoView`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbindVideoView`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultVideoTileController` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultVideoTileController.Type) -> DefaultVideoTileControllerMock.InitializerProxy.Type {
  return DefaultVideoTileControllerMock.InitializerProxy.self
}

// MARK: - Mocked DefaultVideoTile

public final class DefaultVideoTileMock: AmazonChimeSDK.DefaultVideoTile, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DefaultVideoTileMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(logger: AmazonChimeSDK.Logger, tileId: Int, attendeeId: String?, __file: StaticString = #file, __line: UInt = #line) -> DefaultVideoTileMock {
      let mock: DefaultVideoTileMock = DefaultVideoTileMock(logger: `logger`, tileId: `tileId`, attendeeId: `attendeeId`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked state

  override public var `state`: AmazonChimeSDK.VideoTileState {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoTileState)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileState) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoTileState, AmazonChimeSDK.VideoTileState> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoTileState, AmazonChimeSDK.VideoTileState>(mock: self, invocation: invocation)
  }

  public func setState(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileState) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoRenderView

  override public var `videoRenderView`: AmazonChimeSDK.VideoRenderView? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoRenderView?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoRenderView() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoRenderView?, AmazonChimeSDK.VideoRenderView?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoRenderView?, AmazonChimeSDK.VideoRenderView?>(mock: self, invocation: invocation)
  }

  public func setVideoRenderView(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?)

  public override func `bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoRenderView`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView?) -> Void {
      concreteImplementation(`videoRenderView`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bind`(videoRenderView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoRenderView`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(logger: AmazonChimeSDK.Logger, tileId: Int, attendeeId: String?)

  public required override init(logger: AmazonChimeSDK.Logger, tileId: Int, attendeeId: String?) {
    super.init(logger: `logger`, tileId: `tileId`, attendeeId: `attendeeId`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(logger: AmazonChimeSDK.Logger, tileId: Int, attendeeId: String?) ", arguments: [Mockingbird.ArgumentMatcher(`logger`), Mockingbird.ArgumentMatcher(`tileId`), Mockingbird.ArgumentMatcher(`attendeeId`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `renderFrame`(frame: Any?)

  public override func `renderFrame`(frame: Any?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?) -> Void {
      concreteImplementation(`frame`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `renderFrame`(frame: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState)

  public override func `setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`pauseState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoPauseState) -> Void {
      concreteImplementation(`pauseState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setPauseState`(pauseState: @escaping @autoclosure () -> AmazonChimeSDK.VideoPauseState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`pauseState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbind`()

  public override func `unbind`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbind`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbind`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbind`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DefaultVideoTile` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DefaultVideoTile.Type) -> DefaultVideoTileMock.InitializerProxy.Type {
  return DefaultVideoTileMock.InitializerProxy.self
}

// MARK: - Mocked DeviceChangeObserver

public final class DeviceChangeObserverMock: AmazonChimeSDK.DeviceChangeObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeviceChangeObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onAudioDeviceChange`(freshAudioDeviceList: [AmazonChimeSDK.MediaDevice])

  public func `onAudioDeviceChange`(freshAudioDeviceList: [AmazonChimeSDK.MediaDevice]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioDeviceChange`(freshAudioDeviceList: [AmazonChimeSDK.MediaDevice]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`freshAudioDeviceList`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.MediaDevice]) -> Void {
      concreteImplementation(`freshAudioDeviceList`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAudioDeviceChange`(freshAudioDeviceList: @escaping @autoclosure () -> [AmazonChimeSDK.MediaDevice]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.MediaDevice]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`freshAudioDeviceList`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAudioDeviceChange`(freshAudioDeviceList: [AmazonChimeSDK.MediaDevice]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.MediaDevice]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DeviceChangeObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DeviceChangeObserver.Protocol) -> DeviceChangeObserverMock {
  return DeviceChangeObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked DeviceController

public final class DeviceControllerMock: AmazonChimeSDK.DeviceController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      DeviceControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public func `addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice)

  public func `chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: [Mockingbird.ArgumentMatcher(`mediaDevice`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.MediaDevice) -> Void {
      concreteImplementation(`mediaDevice`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `chooseAudioDevice`(mediaDevice: @escaping @autoclosure () -> AmazonChimeSDK.MediaDevice) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`mediaDevice`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`chooseAudioDevice`(mediaDevice: AmazonChimeSDK.MediaDevice) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.MediaDevice) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getActiveCamera`()

  public func `getActiveCamera`() -> AmazonChimeSDK.MediaDevice? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.MediaDevice? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.MediaDevice?)()
    }
  }

  public func `getActiveCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getActiveCamera`() -> AmazonChimeSDK.MediaDevice?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.MediaDevice?, AmazonChimeSDK.MediaDevice?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `listAudioDevices`()

  public func `listAudioDevices`() -> [AmazonChimeSDK.MediaDevice] {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> [AmazonChimeSDK.MediaDevice] {
      return concreteImplementation()
    } else {
      return (implementation as! () -> [AmazonChimeSDK.MediaDevice])()
    }
  }

  public func `listAudioDevices`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`listAudioDevices`() -> [AmazonChimeSDK.MediaDevice]", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> [AmazonChimeSDK.MediaDevice], [AmazonChimeSDK.MediaDevice]>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver)

  public func `removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.DeviceChangeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeDeviceChangeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.DeviceChangeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeDeviceChangeObserver`(observer: AmazonChimeSDK.DeviceChangeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.DeviceChangeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `switchCamera`()

  public func `switchCamera`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `switchCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.DeviceController` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.DeviceController.Protocol) -> DeviceControllerMock {
  return DeviceControllerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked IntervalScheduler

public final class IntervalSchedulerMock: AmazonChimeSDK.IntervalScheduler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      IntervalSchedulerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(intervalMs: Int, callback: @escaping () -> Void, __file: StaticString = #file, __line: UInt = #line) -> IntervalSchedulerMock {
      let mock: IntervalSchedulerMock = IntervalSchedulerMock(intervalMs: `intervalMs`, callback: `callback`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked callback

  override public var `callback`: () -> Void {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "callback.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> () -> Void)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "callback.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (() -> Void) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getCallback() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> () -> Void, () -> Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "callback.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> () -> Void, () -> Void>(mock: self, invocation: invocation)
  }

  public func setCallback(_ newValue: @escaping @autoclosure () -> () -> Void) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (() -> Void) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "callback.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (() -> Void) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked intervalMs

  override public var `intervalMs`: Int {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "intervalMs.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Int)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "intervalMs.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Int) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getIntervalMs() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "intervalMs.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Int, Int>(mock: self, invocation: invocation)
  }

  public func setIntervalMs(_ newValue: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "intervalMs.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked timer

  override public var `timer`: Timer? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "timer.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> Timer?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "timer.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (Timer?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getTimer() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Timer?, Timer?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "timer.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> Timer?, Timer?>(mock: self, invocation: invocation)
  }

  public func setTimer(_ newValue: @escaping @autoclosure () -> Timer?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Timer?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "timer.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (Timer?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(intervalMs: Int, callback: @escaping () -> Void)

  public required override init(intervalMs: Int, callback: @escaping () -> Void) {
    super.init(intervalMs: `intervalMs`, callback: `callback`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(intervalMs: Int, callback: @escaping () -> Void) ", arguments: [Mockingbird.ArgumentMatcher(`intervalMs`), Mockingbird.ArgumentMatcher(`callback`)])
    mockingContext.didInvoke(invocation)
  }

  // MARK: Mocked `start`()

  public override func `start`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public override func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.IntervalScheduler` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.IntervalScheduler.Type) -> IntervalSchedulerMock.InitializerProxy.Type {
  return IntervalSchedulerMock.InitializerProxy.self
}

// MARK: - Mocked Logger

public final class LoggerMock: AmazonChimeSDK.Logger, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      LoggerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `debug`(debugFunction: () -> String)

  public func `debug`(debugFunction: () -> String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debug`(debugFunction: () -> String) -> Void", arguments: [Mockingbird.ArgumentMatcher(Mockingbird.NonEscapingClosure<() -> String>())])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (() -> String) -> Void {
      concreteImplementation(`debugFunction`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `debug`(debugFunction: @escaping @autoclosure () -> () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`debugFunction`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`debug`(debugFunction: () -> String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (() -> String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `default`(msg: String)

  public func `default`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`default`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `default`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`default`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `error`(msg: String)

  public func `error`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`error`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `error`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`error`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `fault`(msg: String)

  public func `fault`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fault`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `fault`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`fault`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `getLogLevel`()

  public func `getLogLevel`() -> AmazonChimeSDK.LogLevel {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getLogLevel`() -> AmazonChimeSDK.LogLevel", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> AmazonChimeSDK.LogLevel {
      return concreteImplementation()
    } else {
      return (implementation as! () -> AmazonChimeSDK.LogLevel)()
    }
  }

  public func `getLogLevel`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getLogLevel`() -> AmazonChimeSDK.LogLevel", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> AmazonChimeSDK.LogLevel, AmazonChimeSDK.LogLevel>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `info`(msg: String)

  public func `info`(msg: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`info`(msg: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`msg`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String) -> Void {
      concreteImplementation(`msg`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `info`(msg: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`msg`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`info`(msg: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setLogLevel`(level: AmazonChimeSDK.LogLevel)

  public func `setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void", arguments: [Mockingbird.ArgumentMatcher(`level`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.LogLevel) -> Void {
      concreteImplementation(`level`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setLogLevel`(level: @escaping @autoclosure () -> AmazonChimeSDK.LogLevel) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`level`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setLogLevel`(level: AmazonChimeSDK.LogLevel) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.LogLevel) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.Logger` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.Logger.Protocol) -> LoggerMock {
  return LoggerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked MediaDevice

public final class MediaDeviceMock: AmazonChimeSDK.MediaDevice, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MediaDeviceMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(label: String, port: AVAudioSessionPortDescription?, videoDevice: VideoDevice?, __file: StaticString = #file, __line: UInt = #line) -> MediaDeviceMock {
      let mock: MediaDeviceMock = MediaDeviceMock(label: `label`, port: `port`, videoDevice: `videoDevice`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked description

  override public var `description`: String {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "description.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> String)()
    }
  }

  public func getDescription() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "description.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> String, String>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(label: String, port: AVAudioSessionPortDescription?, videoDevice: VideoDevice?)

  public required override init(label: String, port: AVAudioSessionPortDescription?, videoDevice: VideoDevice?) {
    super.init(label: `label`, port: `port`, videoDevice: `videoDevice`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(label: String, port: AVAudioSessionPortDescription?, videoDevice: VideoDevice?) ", arguments: [Mockingbird.ArgumentMatcher(`label`), Mockingbird.ArgumentMatcher(`port`), Mockingbird.ArgumentMatcher(`videoDevice`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MediaDevice` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MediaDevice.Type) -> MediaDeviceMock.InitializerProxy.Type {
  return MediaDeviceMock.InitializerProxy.self
}

// MARK: - Mocked MediaPlacement

public final class MediaPlacementMock: AmazonChimeSDK.MediaPlacement, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MediaPlacementMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String, __file: StaticString = #file, __line: UInt = #line) -> MediaPlacementMock {
      let mock: MediaPlacementMock = MediaPlacementMock(audioFallbackUrl: `audioFallbackUrl`, audioHostUrl: `audioHostUrl`, turnControlUrl: `turnControlUrl`, signalingUrl: `signalingUrl`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String)

  public required override init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String) {
    super.init(audioFallbackUrl: `audioFallbackUrl`, audioHostUrl: `audioHostUrl`, turnControlUrl: `turnControlUrl`, signalingUrl: `signalingUrl`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String) ", arguments: [Mockingbird.ArgumentMatcher(`audioFallbackUrl`), Mockingbird.ArgumentMatcher(`audioHostUrl`), Mockingbird.ArgumentMatcher(`turnControlUrl`), Mockingbird.ArgumentMatcher(`signalingUrl`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MediaPlacement` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MediaPlacement.Type) -> MediaPlacementMock.InitializerProxy.Type {
  return MediaPlacementMock.InitializerProxy.self
}

// MARK: - Mocked MeetingSessionConfiguration

public final class MeetingSessionConfigurationMock: AmazonChimeSDK.MeetingSessionConfiguration, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingSessionConfigurationMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(createMeetingResponse: AmazonChimeSDK.CreateMeetingResponse, createAttendeeResponse: AmazonChimeSDK.CreateAttendeeResponse, __file: StaticString = #file, __line: UInt = #line) -> MeetingSessionConfigurationMock {
      let mock: MeetingSessionConfigurationMock = MeetingSessionConfigurationMock(createMeetingResponse: `createMeetingResponse`, createAttendeeResponse: `createAttendeeResponse`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(createMeetingResponse: AmazonChimeSDK.CreateMeetingResponse, createAttendeeResponse: AmazonChimeSDK.CreateAttendeeResponse)

  public required override init(createMeetingResponse: AmazonChimeSDK.CreateMeetingResponse, createAttendeeResponse: AmazonChimeSDK.CreateAttendeeResponse) {
    super.init(createMeetingResponse: `createMeetingResponse`, createAttendeeResponse: `createAttendeeResponse`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(createMeetingResponse: AmazonChimeSDK.CreateMeetingResponse, createAttendeeResponse: AmazonChimeSDK.CreateAttendeeResponse) ", arguments: [Mockingbird.ArgumentMatcher(`createMeetingResponse`), Mockingbird.ArgumentMatcher(`createAttendeeResponse`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MeetingSessionConfiguration` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MeetingSessionConfiguration.Type) -> MeetingSessionConfigurationMock.InitializerProxy.Type {
  return MeetingSessionConfigurationMock.InitializerProxy.self
}

// MARK: - Mocked MeetingSessionCredentials

public final class MeetingSessionCredentialsMock: AmazonChimeSDK.MeetingSessionCredentials, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingSessionCredentialsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendeeId: String, joinToken: String, __file: StaticString = #file, __line: UInt = #line) -> MeetingSessionCredentialsMock {
      let mock: MeetingSessionCredentialsMock = MeetingSessionCredentialsMock(attendeeId: `attendeeId`, joinToken: `joinToken`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(attendeeId: String, joinToken: String)

  public required override init(attendeeId: String, joinToken: String) {
    super.init(attendeeId: `attendeeId`, joinToken: `joinToken`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendeeId: String, joinToken: String) ", arguments: [Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`joinToken`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MeetingSessionCredentials` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MeetingSessionCredentials.Type) -> MeetingSessionCredentialsMock.InitializerProxy.Type {
  return MeetingSessionCredentialsMock.InitializerProxy.self
}

// MARK: - Mocked MeetingSessionStatus

public final class MeetingSessionStatusMock: AmazonChimeSDK.MeetingSessionStatus, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingSessionStatusMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(statusCode: AmazonChimeSDK.MeetingSessionStatusCode, __file: StaticString = #file, __line: UInt = #line) -> MeetingSessionStatusMock {
      let mock: MeetingSessionStatusMock = MeetingSessionStatusMock(statusCode: `statusCode`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(statusCode: AmazonChimeSDK.MeetingSessionStatusCode)

  public required override init(statusCode: AmazonChimeSDK.MeetingSessionStatusCode) {
    super.init(statusCode: `statusCode`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(statusCode: AmazonChimeSDK.MeetingSessionStatusCode) ", arguments: [Mockingbird.ArgumentMatcher(`statusCode`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MeetingSessionStatus` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MeetingSessionStatus.Type) -> MeetingSessionStatusMock.InitializerProxy.Type {
  return MeetingSessionStatusMock.InitializerProxy.self
}

// MARK: - Mocked MeetingSessionURLs

public final class MeetingSessionURLsMock: AmazonChimeSDK.MeetingSessionURLs, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingSessionURLsMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String, __file: StaticString = #file, __line: UInt = #line) -> MeetingSessionURLsMock {
      let mock: MeetingSessionURLsMock = MeetingSessionURLsMock(audioFallbackUrl: `audioFallbackUrl`, audioHostUrl: `audioHostUrl`, turnControlUrl: `turnControlUrl`, signalingUrl: `signalingUrl`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String)

  public required override init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String) {
    super.init(audioFallbackUrl: `audioFallbackUrl`, audioHostUrl: `audioHostUrl`, turnControlUrl: `turnControlUrl`, signalingUrl: `signalingUrl`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(audioFallbackUrl: String, audioHostUrl: String, turnControlUrl: String, signalingUrl: String) ", arguments: [Mockingbird.ArgumentMatcher(`audioFallbackUrl`), Mockingbird.ArgumentMatcher(`audioHostUrl`), Mockingbird.ArgumentMatcher(`turnControlUrl`), Mockingbird.ArgumentMatcher(`signalingUrl`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MeetingSessionURLs` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MeetingSessionURLs.Type) -> MeetingSessionURLsMock.InitializerProxy.Type {
  return MeetingSessionURLsMock.InitializerProxy.self
}

// MARK: - Mocked MeetingSession

public final class MeetingSessionMock: AmazonChimeSDK.MeetingSession, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingSessionMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked audioVideo

  public var `audioVideo`: AmazonChimeSDK.AudioVideoFacade {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "audioVideo.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.AudioVideoFacade)()
    }
  }

  public func getAudioVideo() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.AudioVideoFacade, AmazonChimeSDK.AudioVideoFacade> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "audioVideo.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.AudioVideoFacade, AmazonChimeSDK.AudioVideoFacade>(mock: self, invocation: invocation)
  }

  // MARK: Mocked configuration

  public var `configuration`: AmazonChimeSDK.MeetingSessionConfiguration {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.MeetingSessionConfiguration)()
    }
  }

  public func getConfiguration() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "configuration.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.MeetingSessionConfiguration, AmazonChimeSDK.MeetingSessionConfiguration>(mock: self, invocation: invocation)
  }

  // MARK: Mocked logger

  public var `logger`: AmazonChimeSDK.Logger {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.Logger)()
    }
  }

  public func getLogger() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "logger.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.Logger, AmazonChimeSDK.Logger>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }
}

/// Create a source-attributed `AmazonChimeSDK.MeetingSession` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MeetingSession.Protocol) -> MeetingSessionMock {
  return MeetingSessionMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Meeting

public final class MeetingMock: AmazonChimeSDK.Meeting, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MeetingMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(meetingId: String, mediaPlacement: AmazonChimeSDK.MediaPlacement, __file: StaticString = #file, __line: UInt = #line) -> MeetingMock {
      let mock: MeetingMock = MeetingMock(meetingId: `meetingId`, mediaPlacement: `mediaPlacement`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(meetingId: String, mediaPlacement: AmazonChimeSDK.MediaPlacement)

  public required override init(meetingId: String, mediaPlacement: AmazonChimeSDK.MediaPlacement) {
    super.init(meetingId: `meetingId`, mediaPlacement: `mediaPlacement`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(meetingId: String, mediaPlacement: AmazonChimeSDK.MediaPlacement) ", arguments: [Mockingbird.ArgumentMatcher(`meetingId`), Mockingbird.ArgumentMatcher(`mediaPlacement`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.Meeting` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.Meeting.Type) -> MeetingMock.InitializerProxy.Type {
  return MeetingMock.InitializerProxy.self
}

// MARK: - Mocked MetricsObserver

public final class MetricsObserverMock: AmazonChimeSDK.MetricsObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      MetricsObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onMetricsReceive`(metrics: [AnyHashable: Any])

  public func `onMetricsReceive`(metrics: [AnyHashable: Any]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onMetricsReceive`(metrics: [AnyHashable: Any]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`metrics`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AnyHashable: Any]) -> Void {
      concreteImplementation(`metrics`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onMetricsReceive`(metrics: @escaping @autoclosure () -> [AnyHashable: Any]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`metrics`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onMetricsReceive`(metrics: [AnyHashable: Any]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AnyHashable: Any]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.MetricsObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.MetricsObserver.Protocol) -> MetricsObserverMock {
  return MetricsObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked RealtimeControllerFacade

public final class RealtimeControllerFacadeMock: AmazonChimeSDK.RealtimeControllerFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RealtimeControllerFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalMute`()

  public func `realtimeLocalMute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalMute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalMute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `realtimeLocalUnmute`()

  public func `realtimeLocalUnmute`() -> Bool {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> Bool {
      return concreteImplementation()
    } else {
      return (implementation as! () -> Bool)()
    }
  }

  public func `realtimeLocalUnmute`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`realtimeLocalUnmute`() -> Bool", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Bool, Bool>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver)

  public func `removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.RealtimeObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeRealtimeObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.RealtimeObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeRealtimeObserver`(observer: AmazonChimeSDK.RealtimeObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.RealtimeObserver) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.RealtimeControllerFacade` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.RealtimeControllerFacade.Protocol) -> RealtimeControllerFacadeMock {
  return RealtimeControllerFacadeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked RealtimeObserver

public final class RealtimeObserverMock: AmazonChimeSDK.RealtimeObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      RealtimeObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onAttendeesJoin`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo])

  public func `onAttendeesJoin`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesJoin`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfo`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesJoin`(attendeeInfo: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesJoin`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesLeave`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo])

  public func `onAttendeesLeave`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesLeave`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfo`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesLeave`(attendeeInfo: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesLeave`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesMute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo])

  public func `onAttendeesMute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesMute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfo`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesMute`(attendeeInfo: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesMute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onAttendeesUnmute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo])

  public func `onAttendeesUnmute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesUnmute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.AttendeeInfo]) -> Void {
      concreteImplementation(`attendeeInfo`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAttendeesUnmute`(attendeeInfo: @escaping @autoclosure () -> [AmazonChimeSDK.AttendeeInfo]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`attendeeInfo`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAttendeesUnmute`(attendeeInfo: [AmazonChimeSDK.AttendeeInfo]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.AttendeeInfo]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate])

  public func `onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`signalUpdates`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.SignalUpdate]) -> Void {
      concreteImplementation(`signalUpdates`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onSignalStrengthChange`(signalUpdates: @escaping @autoclosure () -> [AmazonChimeSDK.SignalUpdate]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.SignalUpdate]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`signalUpdates`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onSignalStrengthChange`(signalUpdates: [AmazonChimeSDK.SignalUpdate]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.SignalUpdate]) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onVolumeChange`(volumeUpdates: [AmazonChimeSDK.VolumeUpdate])

  public func `onVolumeChange`(volumeUpdates: [AmazonChimeSDK.VolumeUpdate]) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVolumeChange`(volumeUpdates: [AmazonChimeSDK.VolumeUpdate]) -> Void", arguments: [Mockingbird.ArgumentMatcher(`volumeUpdates`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? ([AmazonChimeSDK.VolumeUpdate]) -> Void {
      concreteImplementation(`volumeUpdates`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onVolumeChange`(volumeUpdates: @escaping @autoclosure () -> [AmazonChimeSDK.VolumeUpdate]) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.VolumeUpdate]) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`volumeUpdates`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onVolumeChange`(volumeUpdates: [AmazonChimeSDK.VolumeUpdate]) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, ([AmazonChimeSDK.VolumeUpdate]) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.RealtimeObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.RealtimeObserver.Protocol) -> RealtimeObserverMock {
  return RealtimeObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked Scheduler

public final class SchedulerMock: AmazonChimeSDK.Scheduler, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SchedulerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `start`()

  public func `start`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `start`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stop`()

  public func `stop`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stop`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stop`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.Scheduler` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.Scheduler.Protocol) -> SchedulerMock {
  return SchedulerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked SignalUpdate

public final class SignalUpdateMock: AmazonChimeSDK.SignalUpdate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      SignalUpdateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendeeInfo: AmazonChimeSDK.AttendeeInfo, signalStrength: AmazonChimeSDK.SignalStrength, __file: StaticString = #file, __line: UInt = #line) -> SignalUpdateMock {
      let mock: SignalUpdateMock = SignalUpdateMock(attendeeInfo: `attendeeInfo`, signalStrength: `signalStrength`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, signalStrength: AmazonChimeSDK.SignalStrength)

  public required override init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, signalStrength: AmazonChimeSDK.SignalStrength) {
    super.init(attendeeInfo: `attendeeInfo`, signalStrength: `signalStrength`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, signalStrength: AmazonChimeSDK.SignalStrength) ", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`), Mockingbird.ArgumentMatcher(`signalStrength`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.SignalUpdate` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.SignalUpdate.Type) -> SignalUpdateMock.InitializerProxy.Type {
  return SignalUpdateMock.InitializerProxy.self
}

// MARK: - Mocked VideoClientController

public final class VideoClientControllerMock: AmazonChimeSDK.VideoClientController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoClientControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `getCurrentDevice`()

  public func `getCurrentDevice`() -> VideoDevice? {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCurrentDevice`() -> VideoDevice?", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: false)
    if let concreteImplementation = implementation as? () -> VideoDevice? {
      return concreteImplementation()
    } else {
      return (implementation as! () -> VideoDevice?)()
    }
  }

  public func `getCurrentDevice`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> VideoDevice?, VideoDevice?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`getCurrentDevice`() -> VideoDevice?", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> VideoDevice?, VideoDevice?>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseResumeRemoteVideo`(_ videoId: UInt32, pause: Bool)

  public func `pauseResumeRemoteVideo`(_ videoId: UInt32, pause: Bool) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseResumeRemoteVideo`(_ videoId: UInt32, pause: Bool) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoId`), Mockingbird.ArgumentMatcher(`pause`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (UInt32, Bool) -> Void {
      concreteImplementation(`videoId`, `pause`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseResumeRemoteVideo`(_ videoId: @escaping @autoclosure () -> UInt32, pause: @escaping @autoclosure () -> Bool) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UInt32, Bool) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoId`), Mockingbird.resolve(`pause`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseResumeRemoteVideo`(_ videoId: UInt32, pause: Bool) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (UInt32, Bool) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `start`(turnControlUrl: String, signalingUrl: String, meetingId: String, joinToken: String)

  public func `start`(turnControlUrl: String, signalingUrl: String, meetingId: String, joinToken: String) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`(turnControlUrl: String, signalingUrl: String, meetingId: String, joinToken: String) -> Void", arguments: [Mockingbird.ArgumentMatcher(`turnControlUrl`), Mockingbird.ArgumentMatcher(`signalingUrl`), Mockingbird.ArgumentMatcher(`meetingId`), Mockingbird.ArgumentMatcher(`joinToken`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (String, String, String, String) -> Void {
      concreteImplementation(`turnControlUrl`, `signalingUrl`, `meetingId`, `joinToken`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `start`(turnControlUrl: @escaping @autoclosure () -> String, signalingUrl: @escaping @autoclosure () -> String, meetingId: @escaping @autoclosure () -> String, joinToken: @escaping @autoclosure () -> String) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, String, String, String) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`turnControlUrl`), Mockingbird.resolve(`signalingUrl`), Mockingbird.resolve(`meetingId`), Mockingbird.resolve(`joinToken`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`start`(turnControlUrl: String, signalingUrl: String, meetingId: String, joinToken: String) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (String, String, String, String) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startLocalVideo`()

  public func `startLocalVideo`() throws -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () throws -> Void {
      try concreteImplementation()
    } else {
      try (implementation as? () throws -> Void)?()
    }
  }

  public func `startLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startLocalVideo`() throws -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () throws -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `startRemoteVideo`()

  public func `startRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `startRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`startRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopAndDestroy`()

  public func `stopAndDestroy`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopAndDestroy`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopAndDestroy`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopAndDestroy`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopLocalVideo`()

  public func `stopLocalVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopLocalVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopLocalVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `stopRemoteVideo`()

  public func `stopRemoteVideo`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `stopRemoteVideo`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`stopRemoteVideo`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `subscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `subscribeToVideoClientStateChange`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `subscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController)

  public func `subscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileController) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `subscribeToVideoTileControllerObservers`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileController) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileController) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`subscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileController) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `switchCamera`()

  public func `switchCamera`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `switchCamera`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`switchCamera`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unsubscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver)

  public func `unsubscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.AudioVideoObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unsubscribeToVideoClientStateChange`(observer: @escaping @autoclosure () -> AmazonChimeSDK.AudioVideoObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeToVideoClientStateChange`(observer: AmazonChimeSDK.AudioVideoObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.AudioVideoObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unsubscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController)

  public func `unsubscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileController) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unsubscribeToVideoTileControllerObservers`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileController) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileController) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unsubscribeToVideoTileControllerObservers`(observer: AmazonChimeSDK.VideoTileController) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileController) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoClientController` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoClientController.Protocol) -> VideoClientControllerMock {
  return VideoClientControllerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VideoRenderView

public final class VideoRenderViewMock: AmazonChimeSDK.VideoRenderView, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoRenderViewMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `renderFrame`(frame: Any?)

  public func `renderFrame`(frame: Any?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?) -> Void {
      concreteImplementation(`frame`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `renderFrame`(frame: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoRenderView` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoRenderView.Protocol) -> VideoRenderViewMock {
  return VideoRenderViewMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VideoTileControllerFacade

public final class VideoTileControllerFacadeMock: AmazonChimeSDK.VideoTileControllerFacade, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoTileControllerFacadeMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int)

  public func `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoView`), Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView, Int) -> Void {
      concreteImplementation(`videoView`, `tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bindVideoView`(videoView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView, tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoView`), Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseRemoteVideoTile`(tileId: Int)

  public func `pauseRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resumeRemoteVideoTile`(tileId: Int)

  public func `resumeRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `resumeRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbindVideoView`(tileId: Int)

  public func `unbindVideoView`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbindVideoView`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoTileControllerFacade` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoTileControllerFacade.Protocol) -> VideoTileControllerFacadeMock {
  return VideoTileControllerFacadeMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VideoTileController

public final class VideoTileControllerMock: AmazonChimeSDK.VideoTileController, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoTileControllerMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `addVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`addVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int)

  public func `bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoView`), Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView, Int) -> Void {
      concreteImplementation(`videoView`, `tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bindVideoView`(videoView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView, tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoView`), Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bindVideoView`(videoView: AmazonChimeSDK.VideoRenderView, tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int)

  public func `onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`), Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`pauseState`), Mockingbird.ArgumentMatcher(`videoId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void {
      concreteImplementation(`frame`, `attendeeId`, `pauseState`, `videoId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onReceiveFrame`(frame: @escaping @autoclosure () -> Any?, attendeeId: @escaping @autoclosure () -> String?, pauseState: @escaping @autoclosure () -> AmazonChimeSDK.VideoPauseState, videoId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`), Mockingbird.resolve(`attendeeId`), Mockingbird.resolve(`pauseState`), Mockingbird.resolve(`videoId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onReceiveFrame`(frame: Any?, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, videoId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?, String?, AmazonChimeSDK.VideoPauseState, Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `pauseRemoteVideoTile`(tileId: Int)

  public func `pauseRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `pauseRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`pauseRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver)

  public func `removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: [Mockingbird.ArgumentMatcher(`observer`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileObserver) -> Void {
      concreteImplementation(`observer`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `removeVideoTileObserver`(observer: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileObserver) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`observer`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`removeVideoTileObserver`(observer: AmazonChimeSDK.VideoTileObserver) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileObserver) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `resumeRemoteVideoTile`(tileId: Int)

  public func `resumeRemoteVideoTile`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `resumeRemoteVideoTile`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`resumeRemoteVideoTile`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbindVideoView`(tileId: Int)

  public func `unbindVideoView`(tileId: Int) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileId`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Int) -> Void {
      concreteImplementation(`tileId`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbindVideoView`(tileId: @escaping @autoclosure () -> Int) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileId`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbindVideoView`(tileId: Int) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Int) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoTileController` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoTileController.Protocol) -> VideoTileControllerMock {
  return VideoTileControllerMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VideoTileObserver

public final class VideoTileObserverMock: AmazonChimeSDK.VideoTileObserver, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoTileObserverMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `onAddVideoTile`(tileState: AmazonChimeSDK.VideoTileState)

  public func `onAddVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAddVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileState) -> Void {
      concreteImplementation(`tileState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onAddVideoTile`(tileState: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onAddVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onPauseVideoTile`(tileState: AmazonChimeSDK.VideoTileState)

  public func `onPauseVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onPauseVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileState) -> Void {
      concreteImplementation(`tileState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onPauseVideoTile`(tileState: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onPauseVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onRemoveVideoTile`(tileState: AmazonChimeSDK.VideoTileState)

  public func `onRemoveVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onRemoveVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileState) -> Void {
      concreteImplementation(`tileState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onRemoveVideoTile`(tileState: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onRemoveVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `onResumeVideoTile`(tileState: AmazonChimeSDK.VideoTileState)

  public func `onResumeVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onResumeVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`tileState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoTileState) -> Void {
      concreteImplementation(`tileState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `onResumeVideoTile`(tileState: @escaping @autoclosure () -> AmazonChimeSDK.VideoTileState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`tileState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`onResumeVideoTile`(tileState: AmazonChimeSDK.VideoTileState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoTileState) -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoTileObserver` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoTileObserver.Protocol) -> VideoTileObserverMock {
  return VideoTileObserverMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VideoTileState

public final class VideoTileStateMock: AmazonChimeSDK.VideoTileState, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoTileStateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(tileId: Int, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState, __file: StaticString = #file, __line: UInt = #line) -> VideoTileStateMock {
      let mock: VideoTileStateMock = VideoTileStateMock(tileId: `tileId`, attendeeId: `attendeeId`, pauseState: `pauseState`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked pauseState

  override public var `pauseState`: AmazonChimeSDK.VideoPauseState {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "pauseState.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoPauseState)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "pauseState.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoPauseState) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getPauseState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoPauseState, AmazonChimeSDK.VideoPauseState> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "pauseState.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoPauseState, AmazonChimeSDK.VideoPauseState>(mock: self, invocation: invocation)
  }

  public func setPauseState(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.VideoPauseState) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "pauseState.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked init(tileId: Int, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState)

  public required override init(tileId: Int, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState) {
    super.init(tileId: `tileId`, attendeeId: `attendeeId`, pauseState: `pauseState`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(tileId: Int, attendeeId: String?, pauseState: AmazonChimeSDK.VideoPauseState) ", arguments: [Mockingbird.ArgumentMatcher(`tileId`), Mockingbird.ArgumentMatcher(`attendeeId`), Mockingbird.ArgumentMatcher(`pauseState`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoTileState` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoTileState.Type) -> VideoTileStateMock.InitializerProxy.Type {
  return VideoTileStateMock.InitializerProxy.self
}

// MARK: - Mocked VideoTile

public final class VideoTileMock: AmazonChimeSDK.VideoTile, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VideoTileMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  // MARK: Mocked state

  public var `state`: AmazonChimeSDK.VideoTileState {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoTileState)()
    }
  }

  public func getState() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoTileState, AmazonChimeSDK.VideoTileState> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "state.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoTileState, AmazonChimeSDK.VideoTileState>(mock: self, invocation: invocation)
  }

  // MARK: Mocked videoRenderView

  public var `videoRenderView`: AmazonChimeSDK.VideoRenderView? {
    get {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.get", arguments: [])
      mockingContext.didInvoke(invocation)
      return (stubbingContext.implementation(for: invocation) as! () -> AmazonChimeSDK.VideoRenderView?)()
    }
    set {
      let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.set", arguments: [ArgumentMatcher(newValue)])
      mockingContext.didInvoke(invocation)
      let implementation = stubbingContext.implementation(for: invocation, optional: true)
      if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView?) -> Void {
        concreteImplementation(newValue)
      } else {
        (implementation as? () -> Void)?()
      }
    }
  }

  public func getVideoRenderView() -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoRenderView?, AmazonChimeSDK.VideoRenderView?> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.get", arguments: [])
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, () -> AmazonChimeSDK.VideoRenderView?, AmazonChimeSDK.VideoRenderView?>(mock: self, invocation: invocation)
  }

  public func setVideoRenderView(_ newValue: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView?) -> Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(newValue)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "videoRenderView.set", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.VariableDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void>(mock: self, invocation: invocation)
  }

  fileprivate init(sourceLocation: Mockingbird.SourceLocation) {
    Mockingbird.checkVersion(for: self)
    self.sourceLocation = sourceLocation
  }

  // MARK: Mocked `bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?)

  public func `bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`videoRenderView`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoRenderView?) -> Void {
      concreteImplementation(`videoRenderView`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `bind`(videoRenderView: @escaping @autoclosure () -> AmazonChimeSDK.VideoRenderView?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`videoRenderView`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`bind`(videoRenderView: AmazonChimeSDK.VideoRenderView?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoRenderView?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `renderFrame`(frame: Any?)

  public func `renderFrame`(frame: Any?) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: [Mockingbird.ArgumentMatcher(`frame`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (Any?) -> Void {
      concreteImplementation(`frame`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `renderFrame`(frame: @escaping @autoclosure () -> Any?) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`frame`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`renderFrame`(frame: Any?) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (Any?) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState)

  public func `setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void", arguments: [Mockingbird.ArgumentMatcher(`pauseState`)])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? (AmazonChimeSDK.VideoPauseState) -> Void {
      concreteImplementation(`pauseState`)
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `setPauseState`(pauseState: @escaping @autoclosure () -> AmazonChimeSDK.VideoPauseState) -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void> {
    let arguments: [Mockingbird.ArgumentMatcher] = [Mockingbird.resolve(`pauseState`)]
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`setPauseState`(pauseState: AmazonChimeSDK.VideoPauseState) -> Void", arguments: arguments)
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, (AmazonChimeSDK.VideoPauseState) -> Void, Void>(mock: self, invocation: invocation)
  }

  // MARK: Mocked `unbind`()

  public func `unbind`() -> Void {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbind`() -> Void", arguments: [])
    mockingContext.didInvoke(invocation)
    let implementation = stubbingContext.implementation(for: invocation, optional: true)
    if let concreteImplementation = implementation as? () -> Void {
      concreteImplementation()
    } else {
      (implementation as? () -> Void)?()
    }
  }

  public func `unbind`() -> Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void> {
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "`unbind`() -> Void", arguments: [])
    return Mockingbird.Mockable<Mockingbird.MethodDeclaration, () -> Void, Void>(mock: self, invocation: invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VideoTile` concrete protocol mock instance.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VideoTile.Protocol) -> VideoTileMock {
  return VideoTileMock(sourceLocation: SourceLocation(file, line))
}

// MARK: - Mocked VolumeUpdate

public final class VolumeUpdateMock: AmazonChimeSDK.VolumeUpdate, Mockingbird.Mock {
  static let staticMock = Mockingbird.StaticMock()
  public let mockingContext = Mockingbird.MockingContext()
  public let stubbingContext = Mockingbird.StubbingContext()
  public let mockMetadata = Mockingbird.MockMetadata(["generator_version": "0.9.0", "module_name": "AmazonChimeSDK"])
  public var sourceLocation: Mockingbird.SourceLocation? {
    get { return stubbingContext.sourceLocation }
    set {
      stubbingContext.sourceLocation = newValue
      VolumeUpdateMock.staticMock.stubbingContext.sourceLocation = newValue
    }
  }

  public enum InitializerProxy {
    public static func initialize(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volumeLevel: AmazonChimeSDK.VolumeLevel, __file: StaticString = #file, __line: UInt = #line) -> VolumeUpdateMock {
      let mock: VolumeUpdateMock = VolumeUpdateMock(attendeeInfo: `attendeeInfo`, volumeLevel: `volumeLevel`)
      mock.sourceLocation = SourceLocation(__file, __line)
      return mock
    }
  }

  // MARK: Mocked init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volumeLevel: AmazonChimeSDK.VolumeLevel)

  public required override init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volumeLevel: AmazonChimeSDK.VolumeLevel) {
    super.init(attendeeInfo: `attendeeInfo`, volumeLevel: `volumeLevel`)
    Mockingbird.checkVersion(for: self)
    let invocation: Mockingbird.Invocation = Mockingbird.Invocation(selectorName: "init(attendeeInfo: AmazonChimeSDK.AttendeeInfo, volumeLevel: AmazonChimeSDK.VolumeLevel) ", arguments: [Mockingbird.ArgumentMatcher(`attendeeInfo`), Mockingbird.ArgumentMatcher(`volumeLevel`)])
    mockingContext.didInvoke(invocation)
  }
}

/// Create a source-attributed `AmazonChimeSDK.VolumeUpdate` class mock metatype.
public func mock(file: StaticString = #file, line: UInt = #line, _ type: AmazonChimeSDK.VolumeUpdate.Type) -> VolumeUpdateMock.InitializerProxy.Type {
  return VolumeUpdateMock.InitializerProxy.self
}
